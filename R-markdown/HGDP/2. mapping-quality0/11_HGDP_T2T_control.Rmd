---
title: "Telomer-to-telomer (T2T) - Validation"
output: rmarkdown::github_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/rpianezza/TE')
```

Idea: run RepeatMasker (RM) on the T2T human genome assembly published in 2022, then create artificial short reads from the same genome and compare the TE copynumbers obtained with the two methods.

First, with this command I run RM, using our customized RepBase reference library as `- lib`.
```
RepeatMasker -gccalc -s -cutoff 200 -no_is -nolow -norna -gff -u -pa 20 -lib /Volumes/Temp2/human_TEs/human-te-dynamics-svn/refg/reflibrary_humans_v6.2.fasta /Volumes/Temp2/riccardo/T2T/genome_assemblies_genome_fasta/ncbi-genomes-2022-11-18/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna

# RepeatMasker version open-4.0.7
# Search Engine: NCBI/RMBLAST [ 2.2.27+ ]
```

Explanation of the RepeatMasker output file:

* `SWscore` = Smith-Waterman score of the match, usually complexity adjusted
* `perc_div` = % substitutions in matching region compared to the consensus
* `perc_del` = % of bases opposite a gap in the query sequence (deleted bp)
* `perc_ins` = % of bases opposite a gap in the repeat consensus (inserted bp)
* `query_sequence` = name of query sequence
* `position_in_query_begin` = starting position of match in query sequence
* `position_in_query_end` = ending position of match in query sequence
* `position_in_query_left` = no. of bases in query sequence past the ending position of match
* `C` = match is with the Complement of the consensus sequence in the database
* `matching_repeat` = name of the matching interspersed repeat
* `repeat_class/family` = the class of the repeat
* `position_in_repeat_begin` = starting position of match in database sequence (using top-strand numbering)
* `position_in_repeat_end` = ending position of match in database sequence
* `position_in_repeat_left` = no. of bases in the repeat consensus sequence 
prior to beginning of the match (so 0 means that the match extended all the way to the end of the repeat consensus sequence)
* `ID` = estimated unique transposon (es. two segments of the same transposon could be separated by another insertion, thus these two sequences have the same ID)
* An asterisk (*) in the final column indicates that there is a higher-scoring match whose domain partly (<80%) includes the domain of this match.

Note that the three column indicating the **position in repeat** are arranged differently for insertions in the two strands:

* For `C` strand: `left`, `end`, `begin`
* For `+` strand: `begin`, `end`, `left`

For simplicity, we kept the order of the `+` strand for all the RM hits and we dealt with this difference in the next analysis calculating `fragment length` and `segment length` differently for the two strands.

Command to remove multiple spaces from the RM output and make it readable in R:
```
less path/rm.out | sed 's/  */ /g' | cut -c2- | > output
```

```{r}
library(tidyverse)
library(ggpubr)

(RM <- read_delim("/Users/rpianezza/TE/T2T/RM_complete/GCF_009914755.1_T2T-CHM13v2.0_genomic_mod.fna.out", delim = " ",skip = 3, col_names = c("SWscore", "perc_div", "perc_del", "perc_ins", "query_sequence", "position_in_query_begin", "position_in_query_end", "position_in_query_left",  "strand", "matching_repeat", "repeat_class/family", "position_in_repeat_begin", "position_in_repeat_end", "position_in_repeat_left", "ID", "other_match")))
```

Here I filter the RM output putting a threshold on the maximum **divergence** percentage (`15`) among the query and the reference, as well as a minimum **length** (`150`, = read length) for the match. I also remove the brackets present in some data to indicate that the sequence aligned to the complement of the reference, which create some problems with the data type and which are not interesting for this analysis.

As output of this chunk, I create a .csv file to analyze in Python using the script *from_RM_to_copynumber*, which estimates the copynumber of each sequence from the ref library found in the RM run. This is done by the script by simply adding the length of each match of a sequence and then dividing by the sequence length.
```{r}
RM_cutoff <- filter(RM, perc_div < 15, position_in_query_end-position_in_query_begin>150) %>% replace_na(list(other_match = "-")) %>% filter(other_match == "-") %>% mutate(position_in_repeat_begin = str_replace(position_in_repeat_begin, "\\(", "")) %>% mutate(position_in_repeat_begin = str_replace(position_in_repeat_begin, "\\)", "")) %>% mutate(position_in_repeat_left = str_replace(position_in_repeat_left, "\\(", "")) %>% mutate(position_in_repeat_left = str_replace(position_in_repeat_left, "\\)", "")) %>% mutate(position_in_query_left = str_replace(position_in_query_left, "\\(", "")) %>% mutate(position_in_query_left = str_replace(position_in_query_left, "\\)", "")) %>% mutate(position_in_repeat_end = str_replace(position_in_repeat_end, "\\(", "")) %>% mutate(position_in_repeat_end = str_replace(position_in_repeat_end, "\\)", "")) %>% mutate(position_in_query_begin = str_replace(position_in_query_begin, "\\(", "")) %>% mutate(position_in_query_begin = str_replace(position_in_query_begin, "\\)", "")) %>% mutate(position_in_query_end = str_replace(position_in_query_end, "\\(", "")) %>% mutate(position_in_query_end = str_replace(position_in_query_end, "\\)", "")) %>% arrange(matching_repeat)

write_csv(RM_cutoff, "/Users/rpianezza/TE/T2T/RM_cutoff.csv")
```

Here I read the output of the Python script, a dictionary with every `sequence` associated with its estimated normalized `copynumber`.
```{r}
RM_copynumbers <- read_csv("/Users/rpianezza/TE/T2T/RM_complete/copynumber_RM.csv", col_names = c("sequence", "copynumber"))
```

Using this command and the Python2 script *create-reads-for-human.py* (can be found in *human_te_dynamics.svn/scripts/*), I create artificial short reads from the T2T genome.
```
python /Users/rpianezza/TE/human-te-dynamics-svn/scripts/create-reads-for-human.py --fasta /Users/rpianezza/TE/T2T/genome_assemblies_genome_fasta/ncbi-genomes-2022-11-22/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna --coverage 30 --read-length 150 --output /Users/rpianezza/TE/T2T/T2T-artificial-reads/reads.fastq.gz --method uniform
```

The artificial reads are then processed into the pipeline to estimate copynumbers (**normalization**). Note that the main script is slightly modified in order to skip the first step (conversion from cram to FASTQ). Here I read the main output file and I create a comparison between the two methods copynumber estimates: RepeatMasker (`RM`) and the pipeline run on artificial short reads (`pipeline`). The color of the points depends on the `mean length` of the RM hits of a particular sequence calculated as follows:

$$\sum_{n=1}^{n} fragment.length/(sequence.length*n)$$

We expect highly fragmented sequences to be more prone to produce outliers across the two methods, thus less reliable. A `mean length` close to 1 means that the sequences in the genome are close to be complete, while a value close to 0 indicates a highly fragmented sequence.

```{r}
artificial <- read_delim("/Users/rpianezza/TE/T2T/T2T-artificial-reads/T2T_artificial_reads.mq10.mapstat", delim = "\t", skip = 8, col_names = c("type", "familyname", "length", "reads", "copynumber"))

art_subset <- select(artificial, familyname, copynumber) %>% arrange(familyname)

RM_subset <- RM_copynumbers %>% mutate(sequence = str_replace(sequence, "_te", "")) %>% mutate(sequence = str_replace(sequence, "_krab", "")) %>% mutate(sequence = str_replace(sequence, "_scg", "")) %>% mutate(sequence = str_replace(sequence, "_scgx", "")) %>% dplyr::rename(familyname = sequence)

RM_mod <- RM_cutoff %>% type_convert() %>% mutate(fragment_len = if_else(strand=="+", abs(position_in_repeat_begin-position_in_repeat_end), abs(position_in_repeat_left-position_in_repeat_end))) %>% mutate(sequence_len = if_else(strand=="+", fragment_len+position_in_repeat_begin+position_in_repeat_left, fragment_len+position_in_repeat_left+position_in_repeat_begin)) %>% arrange(matching_repeat, strand)
```

Here I select only the TE, removing KRAB and SCG from the RM dataset. The resulting CSV file can be used for other analyses.
```{r}
(RM_cutoff_te <- filter(RM_mod, str_detect(matching_repeat, ".te")))

write_csv(RM_cutoff_te, "/Users/rpianezza/TE/T2T/RM_cutoff_te.csv")
```

```{r}
divergence <- group_by(RM_mod, matching_repeat) %>% dplyr::summarise(mean_div = mean(perc_div), mean_length = (sum(fragment_len))/(sequence_len*n())) %>% distinct() %>% mutate(matching_repeat = str_replace(matching_repeat, "_te", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_krab", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_scg", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_scgx", "")) %>% dplyr::rename(familyname = matching_repeat)

cn_comparison <- inner_join(art_subset, RM_subset, by = "familyname") %>% dplyr::rename(pipeline_copynumber = copynumber.x) %>% dplyr::rename(RM_copynumber = copynumber.y)

cn_comparison_final <- inner_join(cn_comparison, divergence, by = "familyname")

ggplot(cn_comparison_final, aes(x=log(pipeline_copynumber), y=log(RM_copynumber), color=mean_length)) +
  geom_point(size=1) + scale_color_gradient(low = "red", high = "green") + labs(color = "Mean length") +
  geom_smooth(method="lm",color="grey", se=F) +
  ylab("Normalized RM copynumber (log)") + xlab("Normalized pipeline copynumber (log)") +
  stat_regline_equation(label.y = 13, aes(label = ..rr.label..), size=5)
```

Here I check if there is a correlation between the copynumbers estimated by the pipeline (normalized) and the number of hits of RM for each sequence in the reference library.
```{r}
RM_reads <- group_by(RM, matching_repeat) %>% count() %>% mutate(matching_repeat = str_replace(matching_repeat, "_te", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_krab", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_scg", "")) %>% mutate(matching_repeat = str_replace(matching_repeat, "_scgx", "")) %>% dplyr::rename(familyname = matching_repeat)

pipeline_reads <- select(artificial, familyname, copynumber) %>% arrange(familyname)

reads_comparison <- inner_join(pipeline_reads, RM_reads, by = "familyname") %>% dplyr::rename(pipeline_copynumber = copynumber, RM_reads = n) %>% inner_join(divergence, bz = "familyname")

ggplot(reads_comparison, aes(x=log(pipeline_copynumber), y=log(RM_reads), color=mean_length)) +
  geom_point(size=1) + scale_color_gradient(low = "red", high = "green") + labs(color = "Mean length") +
  geom_smooth(method="lm",color="grey", se=F) +
  ylab("Non-normalized RM read number (log)") + xlab("Normalized pipeline copynumber (log)") +
  stat_regline_equation(label.y = 14, aes(label = ..rr.label..), size=5)
```

Here I calculate the mean copynumber for each `familyname` among all the HGDP samples and I look for a correlation between these values and the copynumbers estimated by the pipeline in the T2T genome (artificial reads), to see if the values are in line with the previous analysis.
```{r}
HGDPcutoff<-read_delim("/Users/rpianezza/TE/summary-HGDP/USEME_HGDP_complete_reflib6.2_mq10_batchinfo_cutoff0.01.txt",comment="#")
names(HGDPcutoff)<-c("ID","pop","sex","country","type","familyname","length","reads","copynumber","batch")

mean_cn <- group_by(HGDPcutoff, familyname) %>% summarise(min = min(copynumber), mean = mean(copynumber), max = max(copynumber))

T2T_HGDP <- inner_join(mean_cn, art_subset, by="familyname") %>% dplyr::rename(T2T = copynumber) %>% inner_join(divergence, by = "familyname")

ggplot(T2T_HGDP, aes(x=log(mean), y=log(T2T), color=mean_length)) +
  geom_point(size=1) + scale_color_gradient(low = "red", high = "green") + labs(color = " Mean length") +
  geom_smooth(method="lm",color="grey")+
  ylab("HGDP mean copynumber (log)") + xlab("Normalized pipeline copynumber (log)") +
  stat_regline_equation(label.y = 13, aes(label = ..rr.label..), size=5)
```

## Artificial male and female

To further investigate the relationship between the T2T genome and the results of our pipeline on short reads, we created artificial reads from the T2T genome in order to recreate an artificial male and an artificial female.

The ratio is to make reads only for autosomes + X for the female and autosomes + 1/2 X + 1/2 Y for the male, to mimic the real chromosome number.

With this UNIX command I create the autosomes + X (`female`) file. I start from the T2T assembly file and I remove the `Y chromosome` using `sed` and `grep`.
```
less /Users/rpianezza/TE/T2T/genome_assemblies_genome_fasta/ncbi-genomes-2022-11-22/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna | sed '/NA24385/q' | grep -v 'NA24385' | > /Users/rpianezza/TE/T2T/sexes/female
```

Then, I remove also the `X chromosome` to create a file containing only the `autosomes` sequences.
```
less /Users/rpianezza/TE/T2T/genome_assemblies_genome_fasta/ncbi-genomes-2022-11-22/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna | sed '/60946/q' | grep -v '60946' | > /Users/rpianezza/TE/T2T/sexes/autosomes
```

Here I create a separate file containing only the `Y chromosome`.
```
less /Users/rpianezza/TE/T2T/genome_assemblies_genome_fasta/ncbi-genomes-2022-11-22/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna | sed -n '/60948/,$p' | > /Users/rpianezza/TE/T2T/sexes/Y
```

I then combine the `autosomes` with the `Y` to create the autosomes+Y file.
```
cat /Users/rpianezza/TE/T2T/sexes/autosomes /Users/rpianezza/TE/T2T/sexes/y > /Users/rpianezza/TE/T2T/sexes/autosomes_y
```

I create artificial reads (30x coverage) from the autosomes+X file, creating the `artificial female`. Then I create the `artificial male` by generating artificial reads (15x coverage) on autotomes+X and autosomes+Y and combining the resulting files (`males-x` and `male-y`) together.
```
python /Users/rpianezza/TE/human-te-dynamics-svn/scripts/create-reads-for-human.py --fasta /Users/rpianezza/TE/T2T/sexes/autosomes_x --coverage 30 --read-length 150 --output /Users/rpianezza/TE/T2T/sexes/female.fastq.gz --method uniform

python /Users/rpianezza/TE/human-te-dynamics-svn/scripts/create-reads-for-human.py --fasta /Users/rpianezza/TE/T2T/sexes/autosomes_x --coverage 15 --read-length 150 --output /Users/rpianezza/TE/T2T/sexes/male-x.fastq.gz --method uniform

python /Users/rpianezza/TE/human-te-dynamics-svn/scripts/create-reads-for-human.py --fasta /Volumes/Temp1/rpianezza/sexes/autosomes_y --coverage 15 --read-length 150 --output /Volumes/Temp1/rpianezza/sexes/male-y.fastq.gz --method uniform

cat /Volumes/Temp2/riccardo/T2T/T2T-sexes/male-x.fastq /Volumes/Temp2/riccardo/T2T/T2T-sexes/male-y.fastq > /Volumes/Temp2/riccardo/T2T/T2T-sexes/male.fastq
```

Then I processed the two artificial genomes into the pipeline, here are the copynumber estimates:


### Artificial female

```{r}
art_female <- read_tsv("/Volumes/Temp1/rpianezza/TE/T2T/sexes/female.mq10.mapstat", skip=8, col_names = c("type", "familyname", "length", "reads", "copynumber"))

mean_female <- filter(HGDPcutoff, sex=="female") %>% group_by(familyname) %>% summarise(min = min(copynumber), mean = mean(copynumber), max = max(copynumber))

(art_female_HGDP <- inner_join(mean_female, art_female, by="familyname") %>% dplyr::rename(T2T_female = copynumber) %>% inner_join(divergence, by = "familyname"))

ggplot(art_female_HGDP, aes(x=log(mean), y=log(T2T_female), color=mean_length)) +
  geom_point(size=1) + scale_color_gradient(low = "red", high = "green") + labs(color = " Mean length") +
  geom_smooth(method="lm",color="grey")+
  ylab("HGDP mean female copynumber (log)") + xlab("Normalized pipeline copynumber for artificial female (log)") +
  stat_regline_equation(label.y = 13, aes(label = ..rr.label..), size=5)
```

### Artificial male

```{r}
art_male <- read_tsv("/Volumes/Temp1/rpianezza/TE/T2T/sexes/male.mq10.mapstat", skip=8, col_names = c("type", "familyname", "length", "reads", "copynumber"))

mean_male <- filter(HGDPcutoff, sex=="male") %>% group_by(familyname) %>% summarise(min = min(copynumber), mean = mean(copynumber), max = max(copynumber))

(art_male_HGDP <- inner_join(mean_male, art_male, by="familyname") %>% dplyr::rename(T2T_male = copynumber) %>% inner_join(divergence, by = "familyname"))

ggplot(art_male_HGDP, aes(x=log(mean), y=log(T2T_male), color=mean_length)) +
  geom_point(size=1) + scale_color_gradient(low = "red", high = "green") + labs(color = " Mean length") +
  geom_smooth(method="lm",color="grey")+
  ylab("HGDP mean male copynumber (log)") + xlab("Normalized pipeline copynumber for artificial male (log)") +
  stat_regline_equation(label.y = 13, aes(label = ..rr.label..), size=5)
```

### Testing the most different TEs across sexes

To further investigate the relationship between the T2T genome and the HGDP dataset, I checked if the TE which were more different in terms of copynumber between the two sexes in the HGDP (as shown in script 7) are represented also in the T2T genome.
I thus selected some TEs which showed skewed distribution across sexes.

More abundant in **males**:

* ALR1
* HSATI
* ALR_
* ALR
* ALRb

More abundant in **females**:

* ALU
* L1PA4
* THE1B
* L1PA16
* L1

```{r}
data_mf <- filter(HGDPcutoff, type=="te") %>% group_by(familyname, sex) %>% dplyr::summarise(mean=mean(copynumber))
f<-filter(data_mf, sex=="female") %>% rename(f_mean = mean)
m<-filter(data_mf, sex=="male") %>% rename(m_mean = mean)

HGDP_mf <- inner_join(f, m, by = "familyname") %>% select(familyname, f_mean, m_mean) %>% mutate(f_mean_log=log(f_mean), m_mean_log=log(m_mean), diff=m_mean-f_mean, abs_diff=abs(diff), ratio=case_when(diff>=0 ~ m_mean/f_mean, diff<0 ~ f_mean/m_mean), more_in=case_when(diff>=0 ~ "male", diff<0 ~ "female")) %>% arrange(desc(ratio)) %>% mutate(familyname=fct_reorder(familyname,ratio), origin="HGDP")

art_f <- mutate(art_female, sex="female") %>% filter(type=="te", copynumber > 0.001) %>% select(familyname, copynumber) %>% dplyr::rename(f_mean=copynumber) 
art_m <- mutate(art_male, sex="male") %>% filter(type=="te", copynumber > 0.001) %>% select(familyname, copynumber) %>% dplyr::rename(m_mean=copynumber)
art_mf <- full_join(art_f, art_m, by="familyname") %>% mutate(f_mean_log=log(f_mean), m_mean_log=log(m_mean), diff=m_mean-f_mean, abs_diff=abs(diff), ratio=case_when(diff>=0 ~ m_mean/f_mean, diff<0 ~ f_mean/m_mean), more_in=case_when(diff>=0 ~ "male", diff<0 ~ "female")) %>% arrange(desc(ratio)) %>% mutate(familyname=fct_reorder(familyname,ratio), origin="artificial")

final_data <- full_join(HGDP_mf, art_mf)

(subset_TE <- filter(final_data, familyname %in% c("ALR1", "HSATI", "ALR_", "ALR", "ALRb", "ALU", "L1PA4", "THE1B", "L1PA16", "L1")) %>% arrange(familyname))
```

```{r}
ggplot(subset_TE, aes(reorder(familyname, -abs(diff)), abs_diff, fill=more_in, alpha=origin)) + labs(fill = "More abundant in:", alpha = "Data origin:") +
  geom_bar(position="dodge", stat="identity") + ylab("Difference between male/female copynumbers")+ xlab("") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_alpha_discrete(range = c(0.5, 1))

ggplot(subset_TE, aes(reorder(familyname, -abs(diff)), diff, fill=more_in, alpha=origin)) + labs(fill = "More abundant in:", alpha = "Data origin:") +
  geom_bar(position="dodge", stat="identity") + ylab("Difference between male/female copynumbers")+ xlab("") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_alpha_discrete(range = c(0.5, 1))
```

The plot above shows the **difference between male and female copynumber** for the 10 selected TEs, both in the HGDP (the mean value of all the samples) and in the artificial male and female created from the T2T genome and processed into our pipeline to estimate TE copynumber.

The difference shown is absolute, so to distinguish between TE more abundant in males or in females, I filled the basr with different colours. To distinguish between the HGDP and the artificial genomes, I changed the transparency of the bars.

For 9/10 TEs shown in the plot, both the bars show the same colour, meaning that the TE is more abundant in the same sex in the HGDP and in the artificial genomes.

In one case, `ALR_`, the bars show different colours, indicating a difference between the two datasets in terms of sex abundance. This sequence may be prone to produce outliers, or the T2T maybe itself an outlier (es. with lot of insertions on the X chromosome) compared to the mean HGDP.

In general, I think that this plot shows a good sign of robustness for our pipeline.

```{r}
(subset_L1 <- filter(final_data, familyname %in% c("L1PB2c", "L1", "L1PREC1", "L1PA10", "L1PREC2", "L1PA7", "L1PB1", "L1MA1", "L1P_MA2", "L1PA15")) %>% arrange(familyname))

ggplot(subset_L1, aes(reorder(familyname, -abs(diff)), diff, fill=more_in, alpha=origin)) + labs(fill = "More abundant in:", alpha = "Data origin:") +
  geom_bar(position="dodge", stat="identity") + ylab("Difference between male/female copynumbers")+ xlab("") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_alpha_discrete(range = c(0.5, 1))
```

If we look at the most variable LINE-1 across the two sexes, the correlation is even more evident and clean.
 